[1mdiff --git a/src/systems/combat_resolve_phase.c b/src/systems/combat_resolve_phase.c[m
[1mindex dc9ae5f..5ee27d0 100644[m
[1m--- a/src/systems/combat_resolve_phase.c[m
[1m+++ b/src/systems/combat_resolve_phase.c[m
[36m@@ -3,11 +3,49 @@[m
 #include "utils/cli_rendering_util.h"[m
 #include "utils/combat_util.h"[m
 #include "utils/observation_util.h"[m
[32m+[m[32m#include "utils/zone_util.h"[m
[32m+[m
[32m+[m[32m// Check if an entity card is still in any garden zone[m
[32m+[m[32mstatic bool is_entity_in_garden(ecs_world_t *world, ecs_entity_t card, const GameState *gs) {[m
[32m+[m[32m  if (card == 0) return false;[m
[32m+[m
[32m+[m[32m  // Check if card is a leader (leaders are always "in play")[m
[32m+[m[32m  if (ecs_has(world, card, TLeader)) {[m
[32m+[m[32m    return true;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // Check if card is in either player's garden[m
[32m+[m[32m  for (int i = 0; i < MAX_PLAYERS_PER_MATCH; i++) {[m
[32m+[m[32m    ecs_entity_t garden = gs->zones[i].garden;[m
[32m+[m[32m    ecs_entities_t garden_cards = ecs_get_ordered_children(world, garden);[m
[32m+[m[32m    for (int j = 0; j < garden_cards.count; j++) {[m
[32m+[m[32m      if (garden_cards.ids[j] == card) {[m
[32m+[m[32m        return true;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  return false;[m
[32m+[m[32m}[m
 [m
 void HandleCombatResolution(ecs_iter_t *it) {[m
   ecs_world_t *world = it->world;[m
   GameState *gs = ecs_field(it, GameState, 0);[m
 [m
[32m+[m[32m  // Check for combat fizzle - if attacker or defender was removed during response window[m
[32m+[m[32m  bool attacker_valid = is_entity_in_garden(world, gs->combat_state.attacking_card, gs);[m
[32m+[m[32m  bool defender_valid = is_entity_in_garden(world, gs->combat_state.defender_card, gs);[m
[32m+[m
[32m+[m[32m  if (!attacker_valid || !defender_valid) {[m
[32m+[m[32m    // Combat fizzles - one or both participants were removed[m
[32m+[m[32m    cli_render_logf("[CombatResolution] Combat fizzled - %s removed",[m
[32m+[m[32m      !attacker_valid ? "attacker" : "defender");[m
[32m+[m[32m    gs->combat_state.attacking_card = 0;[m
[32m+[m[32m    gs->combat_state.defender_card = 0;[m
[32m+[m[32m    gs->phase = PHASE_MAIN;[m
[32m+[m[32m    return;[m
[32m+[m[32m  }[m
[32m+[m
   resolve_combat(world);[m
 [m
   if (is_game_over(world)) {[m
[1mdiff --git a/src/systems/main.c b/src/systems/main.c[m
[1mindex cf94967..ff22f87 100644[m
[1m--- a/src/systems/main.c[m
[1m+++ b/src/systems/main.c[m
[36m@@ -2,6 +2,7 @@[m
 #include "systems/phase_gate.h"[m
 #include "systems/mulligan_phase.h"[m
 #include "systems/main_phase.h"[m
[32m+[m[32m#include "systems/response_phase.h"[m
 #include "systems/start_phase.h"[m
 #include "systems/end_phase.h"[m
 #include "systems/combat_resolve_phase.h"[m
[36m@@ -11,6 +12,7 @@[m [mvoid init_all_system(ecs_world_t *world) {[m
   init_start_phase_system(world);[m
   init_mulligan_phase_system(world);[m
   init_main_phase_system(world);[m
[32m+[m[32m  init_response_phase_system(world);[m
   init_combat_resolve_phase_system(world);[m
   init_end_phase_system(world);[m
 }[m
[1mdiff --git a/src/systems/main_phase.c b/src/systems/main_phase.c[m
[1mindex 0717383..ec5875e 100644[m
[1m--- a/src/systems/main_phase.c[m
[1m+++ b/src/systems/main_phase.c[m
[36m@@ -1,9 +1,11 @@[m
 #include "systems/main_phase.h"[m
 #include "abilities/ability_registry.h"[m
 #include "abilities/ability_system.h"[m
[32m+[m[32m#include "components/abilities.h"[m
 #include "components/components.h"[m
 #include "utils/zone_util.h"[m
 #include "utils/card_utils.h"[m
[32m+[m[32m#include "utils/player_util.h"[m
 #include "utils/weapon_util.h"[m
 #include "generated/card_defs.h"[m
 #include "utils/cli_rendering_util.h"[m
[36m@@ -116,6 +118,56 @@[m [mstatic void handle_gate_portal(ecs_world_t *world, GameState *gs, ActionContext[m
   cli_render_logf("[MainAction] Gate portal");[m
 }[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * Check if the defending player has any response spells they can play.[m
[32m+[m[32m * Returns true if defender has at least one response spell in hand with enough IKZ to cast.[m
[32m+[m[32m*/[m
[32m+[m[32mstatic bool defender_can_respond(ecs_world_t *world, const GameState *gs, uint8_t defender_index) {[m
[32m+[m[32m  ecs_entity_t hand = gs->zones[defender_index].hand;[m
[32m+[m[32m  ecs_entity_t ikz_area = gs->zones[defender_index].ikz_area;[m
[32m+[m
[32m+[m[32m  // Count available untapped IKZ[m
[32m+[m[32m  ecs_entities_t ikz_cards = ecs_get_ordered_children(world, ikz_area);[m
[32m+[m[32m  uint8_t available_ikz = 0;[m
[32m+[m[32m  for (int i = 0; i < ikz_cards.count; i++) {[m
[32m+[m[32m    if (!is_card_tapped(world, ikz_cards.ids[i])) {[m
[32m+[m[32m      available_ikz++;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // Check IKZ token[m
[32m+[m[32m  ecs_entity_t defender_player = gs->players[defender_index];[m
[32m+[m[32m  const IKZToken *ikz_token = ecs_get(world, defender_player, IKZToken);[m
[32m+[m[32m  if (ikz_token && ikz_token->ikz_token != 0 && !is_card_tapped(world, ikz_token->ikz_token)) {[m
[32m+[m[32m    available_ikz++;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // Check if any card in hand is a response spell with affordable cost[m
[32m+[m[32m  ecs_entities_t hand_cards = ecs_get_ordered_children(world, hand);[m
[32m+[m[32m  for (int i = 0; i < hand_cards.count; i++) {[m
[32m+[m[32m    ecs_entity_t card = hand_cards.ids[i];[m
[32m+[m
[32m+[m[32m    // Check if it's a spell with AResponse timing[m
[32m+[m[32m    if (!is_card_type(world, card, CARD_TYPE_SPELL)) continue;[m
[32m+[m[32m    if (!ecs_has(world, card, AResponse)) continue;[m
[32m+[m
[32m+[m[32m    // Check if we have the ability registered[m
[32m+[m[32m    const CardId *card_id = ecs_get(world, card, CardId);[m
[32m+[m[32m    if (!card_id || !azk_has_ability(card_id->id)) continue;[m
[32m+[m
[32m+[m[32m    // Check IKZ cost[m
[32m+[m[32m    const IKZCost *ikz_cost = ecs_get(world, card, IKZCost);[m
[32m+[m[32m    if (!ikz_cost) continue;[m
[32m+[m
[32m+[m[32m    if (ikz_cost->ikz_cost <= available_ikz) {[m
[32m+[m[32m      // Found at least one playable response spell[m
[32m+[m[32m      return true;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  return false;[m
[32m+[m[32m}[m
[32m+[m
 /**[m
  * Expected Action: ACT_ATTACK, gaden_attacker_index, defender_index (opponent tapped garden entity or leader)[m
  * attacker_index and defender_index of 5 is the leader[m
[36m@@ -139,20 +191,16 @@[m [mstatic void handle_attack(ecs_world_t *world, GameState *gs, ActionContext *ac)[m
     return;[m
   }[m
 [m
[31m-  /*[m
[31m-  TODO: Only go to response window under these conditions:[m
[31m-  - has a response spell and enough IKZ[m
[31m-  - has an untapped entity in the garden with the defender tag[m
[31m-  - has any entities with effects that can be triggered on attack[m
[31m-  */[m
[31m-  // if (defender_can_respond(world, gs)) {[m
[31m-  //   gs->phase = PHASE_RESPONSE_WINDOW;[m
[31m-  //   gs->active_player_index = (gs->active_player_index + 1) % MAX_PLAYERS_PER_MATCH;[m
[31m-  // } else {[m
[32m+[m[32m  // Check if defender can respond (has response spells and IKZ)[m
[32m+[m[32m  uint8_t defender_index = (gs->active_player_index + 1) % MAX_PLAYERS_PER_MATCH;[m
[32m+[m[32m  if (defender_can_respond(world, gs, defender_index)) {[m
[32m+[m[32m    gs->phase = PHASE_RESPONSE_WINDOW;[m
[32m+[m[32m    gs->active_player_index = defender_index;[m
[32m+[m[32m    cli_render_logf("[MainAction] Attack declared - defender has response options");[m
[32m+[m[32m  } else {[m
     gs->phase = PHASE_COMBAT_RESOLVE;[m
[31m-  // }[m
[31m-[m
[31m-  cli_render_logf("[MainAction] Attack");[m
[32m+[m[32m    cli_render_logf("[MainAction] Attack declared - proceeding to combat");[m
[32m+[m[32m  }[m
 }[m
 [m
 /**[m
